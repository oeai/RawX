на вершине работы rawx мы получаем виртуальное linux-compatible ядро, которое работает с процессами пользователя, то есть реальное ядро надёжно защищено за виртуальной прослойкой, но также это значит, что мы можем иметь столько ядер, сколько позволят ресурсы и будет держать железо, поэтому нужно заниматься распределением памяти и ресурсов цп между пользователями - это примерно как виртуальная машина, только без машины, мы обращаемся к сервисам ядра, возможно это уже реализовано в KVM, то есть мы виртуализируем не ядро и машину, а только высокоуровневые процессы
В общем ядро загружается и перехватывает связи от разных библиотек, эмулирует окружение в каких-то странных случаях и эмулирует структуры дистрибутивов, когда это необходимо для каждого пользователя или процесса.
иногда, я представляю себе пользователей как процесс, а процессы как пользователей - такая модель может показать как нужно распределять программы между пользователями, почему один процесс не может иметь разных пользователей? Сейчас каждый пользователь запускает свою копию программы, хотя ему требуется в основном только некоторые её функции, можно разделить эту программу на базовую логику, системные библиотеки и пользовательские данные
тогда каждому не нужно будет запускать "свой" браузер - у всех пользователей запущен один процесс в котором загружена базовая логика и системные библиотеки, а все пользовательские уже загружаются в отдельное пространство памяти, намного меньшее, чем сама программа. Работа пользователей происходит только с раздельным кэшем и памятью, персональные настройки содержатся в профиле и сохраняются в слепке памяти браузера для конкретного пользователя, и когда нет активности всех пользователей этот процесс также выгружается целиком из памяти в squashfs или img.gz, то есть если процесс один раз запустился удачно и завершился тоже удачно, то этот образ процесса сохраняется и используется системой без повторной загрузки всех конфигураций, библиотек и интерпретаторов - загружается слепок (снимок) памяти этого процесса, который сразу же работает аналогично rawx ядру, а пользователи подключают свои настройки к этому процессу и работают через агентов.
User :
- app
--- applets; audit; browser; business; develop; graphic; network; data; mail; system; sound; video; text; games;
- config
-- local; share;
- dev
--- in; out; shared;
- home
--- %users%
- local
--- bin; cache; etc; include; lib; sbin; share; store; tmp;
- net
--- files; ports; shared;
- ports
--- opened; audit; closed;
- var
--- cache; lock; log; opt; run; spool; tmp;

Можно предположить работу некоторых программ в виде squashfs модулей как это сделано в магос - для доустим анонимности или создания особого окружения, которое могло бы возвращаться в исходное состояние после перезапуска, но вообще есть смысл и сохранять последнее состояние приложения, без его начальной загрузки, то есть снова разговор о том, чтобы делать снимок памяти и точки подключения программы к ядру и библиотекам, поэтому видимо нужно предусмотреть такие точки и возможности в rawx-ядре. 
