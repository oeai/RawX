Зная, что все данные будут затем перелинкованы с помощью aufs можно попробовать разделить их в более удобоваримом для компьютера виде,
думаю, что не стоит все исполняемые файлы скидывать в одну директорию, так как это отнимает время при листинге, поиске и сверке файлов в этой директории, разделим их на кучи по крайней мере имеющие человеческую логику, к примеру 1,2,3-/a/b/c как например в spool/squid иерархии, но я думаю, что может быть будет лучше разделить следующим образом scripts/php.js.sh and execs/c.java.fortran texts/html.txt.pdf - то есть такая обратная сортировка по расширению файла, чтобы было легче определять интерпретатор или программу для открытия этого типа файлов интегрированно в системные процессы, чтобы в любом случае любой jpg можно было найти в data/img/jpg а любой cron script в scripts/sh. я не полностью уверен, что это обязательно должно быть именно так, просто думаю, что если все разрешения и запреты в ядре примерно одинаковы и исполняются от одного пользователя, то нужды в разделении на дополнительные папки вообще-то нет - эта логика нужна скорее для админов и программистов, а компьютеру нужна точка начала файла и в какой буфер его загружать\выгружать, поэтому может быть просто вот такое имя 01.011.this.program.file.jpg - да, это новая /non-unix/ схема и здесь может быть также отмечен и приоритет и порядок загрузки файла ядром.
а удобная для людей форма появится только на следующем более высоком уровне, который может легко воспроизвести схему данных unix с помощью пустых жестких симлинков в squashfs
и загруженное в память исполняемое ядро, может быть хотя бы раз перекомпилировано в соответствии с теми задачами, которые оно выполняет для каждой машины, примерно как initrd.img, чтобы не нужно было обнаруживать и загружать несуществующие модули оборудования и это своеобразная заточка ядра под железо и наиболее частые задачи, т.к. такую статистику вполне можно собрать за несколько рабочих сеансов, а выхлоп будет в более тонком распределении ресурсов и простой проверке на идентичность оборудования - тогда сразу может загружаться заточенное ядро в память (слепок - snapshot) бех инициализации и прочего, на него сшиваются базовые функции загрузочного ядра и сразу после загрузки в память это ядро уже может работать.
После первой волны загрузка ядра заканчивается, а вторая вызывает расширенные сервисы системы и оборудования - сеть, x.org, cron, дополнительные устройства, файловые системы, управление для пользователей и всё остальное, что связано с базовой функциональностью системы, то есть gnome,apache,squid здесь не грузятся, а загружаются компиляторы, интерпретаторы, драйвера, шрифты, чтобы пользователь уже мог справляться со своими сервисами
на второй волне выстраивается стандартная никсовая модель /usr/lib/bin чтобы создать рабочую среду для unix/gnu программ с помощью aufs,zfs или виртуальных машин, чтобы можно было отойти от уровня абстракции rawx ядра и эмулировать через него работу gnu/linux модели для интерфейсов конечного пользователя.


System :
- block
- busses
- cache
--- spool; tmp;
- classes
- compatible
- compilers
--- gcc4; gcc3;
- configs
- current
- daemons
- databases
- environment
- execs
- filesystems
--- available; memory; mounted; virtual;
- hardware
--- audio; devices; firmware; networking; peripheral; snapshot; storage; usb; video;
- hypervisors
- includes
- inits
--- zero; level; max;
- interprets
--- php; jre; python; qt
- libraries
- modules
- network
- optional
- power
- scripts
- security
- settings
- structures
--- arch; debian; gentoo; redhat; slackware;
- variable 
