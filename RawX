процесс загрузки часто бывает достаточно долгим (относительно исполнения программ например) и это может быть упрощено с помощью профилей оборудования и слепков памяти
я уже предлагал использовать модель simutrans x-kernel, может быть оно уже работает, а может быть когда-нибудь сделают, потому что альтернатив не так много
simutrans x-kernel суть в том чтобы использовать схему транзакций и положение ядра в памяти, для того чтобы распределять потоки между разными ядрами процессора, чтобы в итоге получить значительное снижение времени обработки используя вычислительные фабрики всех ядер процессора, а не одного
тут будут загружаться базовые инструкции - cpu mem bus, чтобы первая волна сервисов могла определить базовое оборудование и подгрузить для него модули, но ещё раньше активируется первичный пользователь (root), у каждого компа должен быть свой хэш-код для этого пользователя, чтобы был собственник всех процессов и ресурсов. Для меня это важно так как сейчас любой root может просматривать файлы на не зашифрованной системе и получать доступ к любому железу. Поэтому я решил что должен быть system-root-hash user, который может проходить аутентификацию, если пользователь не игнорировал такую функцию при установке. Этот же хэш может использоваться в качестве соли для шифрования user/home, pam/ssl и поэтому pam-auth сервис также должен загружаться в первой волне вместе с базовым оборудованием, чтобы можно было провести дополнительную аутентификацию - клавиатура, видео, звук (ага, хочется голосовой аутентификации и голосовых команд) , может быть хранилища данных. Я думаю всё это уже делается ядром линукса, нужно только поднять аутентификацию, чтобы затем можно было управлять ресурсами хэш-пользователем и делегировать их реальным пользователям.

Boot :
- bin
- config
--- fonts; boot; discover; fstab; initramfs; mdadm; modprobe; udev; lvm;
- dev
- kernel
--- include; blackslist; modules; options; postinst; postrm; source;
- lib

это визуальная модель ядра
конус - root user
куб - boot kernel
икосаэдры - первая волна сервисов ядра
сферы - вторая волна сервисов
бублики - это периферия подгружаемая сервисами от hash-root пользователя
на самом верху - прозрачный для пользователей процесс окружения
задача review of "not unix" - (понять и простить) сделать более гибкой и стабильной систему
примерно выделяется три состояния
logic-structure-data and also boot-system-user 

Некоторые поставленные задачи будут требовать статического расположения некоторых входов\выходов ядра, чтобы другие программы могли обращаться к ним напрямую и это может быть прописано при компиляции программ, тем не менее такие библиотеки не будут слишком частыми и в целом нужно только подключать к ним агентов пользовательского уровня, допустим эти агенты будут справляться с назначением запросов и ответов - станут своеобразными интеллектуальными службами, для них нужно обеспечить высокую скорость работы, поэтому и предлагаются статические адреса памяти - буфферы-стэки для определённых библиотек, можно это сравнить с разбиением диска на различные области. После вторичной перекомпиляции ядра свободные адреса памяти будут точно известны, если задать небольшой отрезок для обмена данными между библиотеками, то теоретически это может помочь в решении некоторых задач.
Модель Х-ядра предполагает использование нескольких ядер и распределение между ними функций общего Linux-ядра, в такой модели должна быть достаточно жёсткая структура распараллеливания функций и распределения ресурсов-ядер процессор-а(-ов), а значит, необходима будет и углублённая работа с памятью, которая возможно уже создаст определённые статические точки для внутренней работы, я думаю, что нужно будет подключать библиотеки напрямую к этим точкам - компиляция будет проходить на-лету. А по факту компиляции не нужно будет происходить и не будет происходить традиционной загрузки приложения, т.к. приложение будет занимать своё прежнее место в памяти вместе со всеми необходимыми модулями из снимка памяти сохранённого в squashfs и подключаться к базовым точкам входа rawx-ядра.
Возможные проблемы будут возникать при недостатке памяти и вынужденном переносе программ из своей области в чужую, тогда необходима будет перезагрузка этих программ для перекомпиляции их squash-образа в соответствии с новой конституцией памяти, вероятно, следует ввести приоритезацию для процессов, чтобы не возникало лишних конфликтов.


Профилирование ядра
Несколько уровней загрузки ядра позволяют возвращаться на уровень ниже и скидывать накопленные ошибки или просто выгружать программы и оборудование из памяти, это позволяет создавать профили ядра для выполнения определённых ёмких задач, например, виртуальные машины используют достаточно много железных ресурсов, но не требуют загрузки всех компиляторов и библиотек, а вычисление 3д моделей или программирование-компиляция кода нуждаются в загрузке только некоторых библиотек и могут полностью загрузить систему, то есть требуют мощности цп и памяти для узкого диапазона задач. В таких случаях может происходить перепрофилирование ядра на-лету и для этого также могут пригодиться карты памяти программ и библиотек. В принципе уже сейчас ядро линукса позволяет выгружать и загружать модули и драйвера во время работы, задача заключается в том, чтобы делать это автоматически в зависимости от запущенных приложений (задач), чтобы вмешательства пользователя не требовалось, а функций было не так много, в то же время, чтобы не нужно было проводить поиск этих функций по стэкам памяти во время исполнения программ. 
